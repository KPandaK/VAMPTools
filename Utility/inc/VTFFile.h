#ifndef VTFFILE_H
#define VTFFILE_H

#include <assert.h>

#include "basicmath.h"
#include "imageformat.h"

#pragma pack(1)
struct VTFImageFormatInfo
{
public:
	char *Name;				//!< Enumeration text equivalent.
	int	BitsPerPixel;		//!< Format bits per pixel.
	int BytesPerPixel;		//!< Format bytes per pixel.
	int RedBitsPerPixel;	//!< Format red bits per pixel.  0 for N/A.
	int GreenBitsPerPixel;	//!< Format green bits per pixel.  0 for N/A.
	int BlueBitsPerPixel;	//!< Format blue bits per pixel.  0 for N/A.
	int AlphaBitsPerPixel;	//!< Format alpha bits per pixel.  0 for N/A.
	bool bIsCompressed;		//!< Format is compressed (DXT).
	bool bIsSupported;		//!< Format is supported
};

typedef enum tagVTFImageFlag
{
	TEXTUREFLAGS_POINTSAMPLE								= 0x00000001,
	TEXTUREFLAGS_TRILINEAR									= 0x00000002,
	TEXTUREFLAGS_CLAMPS										= 0x00000004,
	TEXTUREFLAGS_CLAMPT										= 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC								= 0x00000010,
	TEXTUREFLAGS_HINT_DXT5									= 0x00000020,
	TEXTUREFLAGS_SRGB										= 0x00000040, // Originally internal to VTex as TEXTUREFLAGS_NOCOMPRESS.
	TEXTUREFLAGS_DEPRECATED_NOCOMPRESS						= 0x00000040,
	TEXTUREFLAGS_NORMAL										= 0x00000080,
	TEXTUREFLAGS_NOMIP										= 0x00000100,
	TEXTUREFLAGS_NOLOD										= 0x00000200,
	TEXTUREFLAGS_MINMIP										= 0x00000400,
	TEXTUREFLAGS_PROCEDURAL									= 0x00000800,
	TEXTUREFLAGS_ONEBITALPHA								= 0x00001000, //!< Automatically generated by VTex.
	TEXTUREFLAGS_EIGHTBITALPHA								= 0x00002000, //!< Automatically generated by VTex.
	TEXTUREFLAGS_ENVMAP										= 0x00004000,
	TEXTUREFLAGS_RENDERTARGET								= 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET							= 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE							= 0x00020000,
	TEXTUREFLAGS_SINGLECOPY									= 0x00040000,
	TEXTUREFLAGS_UNUSED0									= 0x00080000, //!< Originally internal to VTex as TEXTUREFLAGS_ONEOVERMIPLEVELINALPHA.
	TEXTUREFLAGS_DEPRECATED_ONEOVERMIPLEVELINALPHA			= 0x00080000,
	TEXTUREFLAGS_UNUSED1									= 0x00100000, //!< Originally internal to VTex as TEXTUREFLAGS_PREMULTCOLORBYONEOVERMIPLEVEL.
	TEXTUREFLAGS_DEPRECATED_PREMULTCOLORBYONEOVERMIPLEVEL	= 0x00100000,
	TEXTUREFLAGS_UNUSED2									= 0x00200000, //!< Originally internal to VTex as TEXTUREFLAGS_NORMALTODUDV.
	TEXTUREFLAGS_DEPRECATED_NORMALTODUDV					= 0x00200000,
	TEXTUREFLAGS_UNUSED3									= 0x00400000, //!< Originally internal to VTex as TEXTUREFLAGS_ALPHATESTMIPGENERATION.
	TEXTUREFLAGS_DEPRECATED_ALPHATESTMIPGENERATION			= 0x00400000,
	TEXTUREFLAGS_NODEPTHBUFFER								= 0x00800000,
	TEXTUREFLAGS_UNUSED4									= 0x01000000, //!< Originally internal to VTex as TEXTUREFLAGS_NICEFILTERED.
	TEXTUREFLAGS_DEPRECATED_NICEFILTERED					= 0x01000000,
	TEXTUREFLAGS_CLAMPU										= 0x02000000,
	TEXTUREFLAGS_VERTEXTEXTURE								= 0x04000000,
	TEXTUREFLAGS_SSBUMP										= 0x08000000,
	TEXTUREFLAGS_UNUSED5									= 0x10000000, //!< Originally TEXTUREFLAGS_UNFILTERABLE_OK.
	TEXTUREFLAGS_DEPRECATED_UNFILTERABLE_OK					= 0x10000000,
	TEXTUREFLAGS_BORDER										= 0x20000000,
	TEXTUREFLAGS_DEPRECATED_SPECVAR_RED						= 0x40000000,
	TEXTUREFLAGS_DEPRECATED_SPECVAR_ALPHA					= 0x80000000,
	TEXTUREFLAGS_LAST										= 0x20000000,
	TEXTUREFLAGS_COUNT										= 30
} VTFImageFlag;

//! VTF image cubemap face indices.
typedef enum tagVTFCubeMapFace
{
	CUBEMAP_FACE_RIGHT = 0,		// +x
	CUBEMAP_FACE_LEFT,			// -x
	CUBEMAP_FACE_BACK,			// +y
	CUBEMAP_FACE_FRONT,			// -y
	CUBEMAP_FACE_UP,			// +z
	CUBEMAP_FACE_DOWN,			// -z
	CUBEMAP_FACE_SphereMap,		// fall back
	CUBEMAP_FACE_COUNT
} VTFCubeMapFace;

struct TTHHeader
{
	// Should be 'TTH\0'
	char sig[4];
	short NumVTF;
	unsigned short Flags;
	int VTFSize;

	char Padding2[96];
};

struct VTFHeader
{
	char		signature[4];			// File signature ("VTF\0").
	unsigned int	version[2];			// version[0].version[1] (currently 7.2 - 7.1 for VTMB data).
	unsigned int	headerSize;			// Size of the header struct (16 byte aligned; currently 80 bytes).

	unsigned short	width;				// Width of the largest mipmap in pixels. Must be a power of 2.
	unsigned short	height;				// Height of the largest mipmap in pixels. Must be a power of 2.
	unsigned int	flags;				// VTF flags.
	unsigned short	frames;				// Number of frames, if animated (1 for no animation).
	unsigned short	firstFrame;			// First frame in animation (0 based).

	VectorAligned	reflectivity;

	float			bumpScale;			// Bumpmap scale.
	ImageFormat		imageFormat;		// High resolution image format.
	unsigned char	numMipLevels;		// Number of mipmaps.
	ImageFormat		lowResImageFormat;	// Low resolution image format (always DXT1).
	unsigned char	lowResImageWidth;	// Low resolution image width.
	unsigned char	lowResImageHeight;	// Low resolution image height.
};

#pragma pack()

// Utility class for dealing with various texture formats
class VTFFile
{
public:

	VTFFile();
	~VTFFile();

	// Sets the internal size of the VTF file data and allocates the buffer
	void InitializeBuffers( int Size );
	// Returns the current buffer size
	inline int GetBufferSize() { return m_nBufferSize; }
	// Get the buffer pointer
	inline unsigned char *GetBuffer() { return m_pBuffer; }

	// Returns the VTF Header
	inline VTFHeader *GetVTFHeader() const { return m_pHeader; }
	// Returns a pointer to the start of the low res data block
	inline const unsigned char *GetLowResData() { return m_pLowResData; }
	// Returns a pointer to the start of the high res data block
	inline const unsigned char *GetHighResData() { return m_pHighResData; }

	// Set the low res data values
	inline void SetLowResData( int Offset, int Size )
	{
		m_pLowResData = m_pBuffer + Offset;
		m_nLowResDataSize = Size;
	}

	// Set the high res data values
	inline void SetHighResData( int Offset, int Size )
	{
		m_pHighResData = m_pBuffer + Offset;
		m_nHighResDataSize = Size;
	}
	
	// Utility funcs

	/*!
		Returns a pointer to the image data for a given frame, face and MIP level.

		\param uiFrame is the desired frame.
		\param uiFace is the desired face.
		\param uiSlice is the desired z slice.
		\param uiMipmapLevel is the desired MIP level.
		\note Frames start at index 0 for the first frame. Faces start at index 0
		for the first face. Cubemaps have 6 faces, others only 1. MIP levels start
		at index 0 for the largest image moving down in size.
	*/
	unsigned char* GetData( int Frame, int Face, int Slice, int MipmapLevel ) const;

	int GetDepth() const;		//!< Returns the depth of the image in pixels from the VTF header.
	int GetFrameCount() const;	//!< Returns the frame count from the VTF header.
	int GetFaceCount() const;	//!< Returns the face count from the VTF header.
	int GetMipmapCount() const;	//!< Returns the number of MIP levels in the image from the VTF header.

	// Convert the data from one format to a different one
	bool Convert( unsigned char *Source, unsigned char *Dest, int Width, int Height, ImageFormat SourceFmt, ImageFormat DestFmt );

	// DXTn format decompression functions
	static bool DecompressDXT1( unsigned char* src, unsigned char* dst, unsigned int Width, unsigned int Height );
	static bool DecompressDXT3( unsigned char* src, unsigned char* dst, unsigned int Width, unsigned int Height );
	static bool DecompressDXT5( unsigned char* src, unsigned char* dst, unsigned int Width, unsigned int Height );

	//!< Flips an image vertically along its X-axis.
	static void FlipImage( unsigned char* ImageDataRGBA8888, int Width, int Height );

	inline const char *GetFormatName( ImageFormat InFmt=IMAGE_FORMAT_UNKNOWN )
	{
		if( InFmt == IMAGE_FORMAT_UNKNOWN )
		{
			InFmt = m_pHeader->imageFormat;
		}

		if( InFmt >= 0 )
		{
			return GetImageFormatInfo(InFmt).Name;
		}
		return "Unknown";
	}

	// Return the image format info
	static const VTFImageFormatInfo& GetImageFormatInfo( ImageFormat Fmt );
	// Compute the size of an image
	static int ComputeImageSize( int Width, int Height, int Depth, enum ImageFormat Fmt  );
	// Compute the total size of all the mips
	static int ComputeImageSize( int Width, int Height, int Depth, int NumMips, enum ImageFormat Fmt );

private:

	// Calculates where in the VTF image the data begins
	unsigned int ComputeDataOffset( int Frame, int Face, int Slice, int MipmapLevel, ImageFormat ImageFormat ) const;
	// Compute how much memory a specific MIP map level needs
	static unsigned int ComputeMipmapSize( int Width, int Height, int Depth, int MipmapLevel, ImageFormat ImageFmt );
	// Compute the dimensions of a specific MIP level
	static void ComputeMipmapDimensions( int Width, int Height, int Depth, int MipmapLevel, int &MipmapWidth, int &uiMipmapHeight, int &MipmapDepth );

	unsigned char *m_pBuffer;
	unsigned int m_nBufferSize;

	VTFHeader *m_pHeader;

	unsigned char *m_pLowResData;
	int m_nLowResDataSize;

	unsigned char *m_pHighResData;
	int m_nHighResDataSize;
};

#endif // VTFFILE_H